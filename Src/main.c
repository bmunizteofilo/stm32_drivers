/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <string.h>
#include "gpio.h"
#include "rcc.h"
#include "systick.h"
#include "usart_irq_dma.h"
#include "usart_poll.h"
#include "spi_poll.h"
#include "spi_irq_dma.h"
#include "tim.h"
#include "i2c_poll.h"
#include "i2c_irq_dma.h"
#include "adc_poll.h"
#include "watchdog.h"

#ifdef __EXEMPLO_BOTAO__
/**
 *  led on/off por botão com interrupção
 * e pa8 como saida do clock principal do core
 */
static void botao_cb(void) {

    /* ação: alterna LED PA5 */
    gpio_toggle_pin(GPIOA, 5);
}

int main(void){
    /* Configura clock do core para 48 MHz via HSI */
    rcc_reset_to_hsi();
    if (!rcc_set_sysclk_from_hsi(48000000UL, RCC_AHB_DIV1, RCC_APB_DIV1)) {
        while (1) {} // erro
    }

    /* Lê clocks atuais */
    rcc_clocks_t clk;
    rcc_get_clocks(&clk);

    /* PA8 como saída MCO (Alternate Function 0) */
    gpio_pin_init(GPIOA, 8, GPIO_MODE_ALT,
                  GPIO_OTYPE_PUSHPULL,
                  GPIO_SPEED_HIGH,
                  GPIO_PUPD_NONE);
    gpio_pin_set_altfunc(GPIOA, 8, GPIO_AF0);

    /* Configura MCO para SYSCLK, sem prescaler (divisor 1) */
    rcc_config_mco(0b100, 0b000);

    /* LED PA5 como saída push-pull, pull-none, alta velocidade */
    gpio_pin_init(GPIOA, 5, GPIO_MODE_OUTPUT, GPIO_OTYPE_PUSHPULL, GPIO_SPEED_HIGH, GPIO_PUPD_NONE);

    /* Botão PC13 como input com pull-up */
    gpio_pin_init(GPIOC, 13, GPIO_MODE_INPUT, GPIO_OTYPE_PUSHPULL,
                  GPIO_SPEED_LOW, GPIO_PUPD_UP);

    /* Roteia EXTI13 para PC13 e configura interrupção por borda de descida */
    gpio_exti_route(GPIOC, 13);
    gpio_exti_configure_line(13, GPIO_EXTI_TRIGGER_FALLING, true);
    gpio_exti_set_callback(13, botao_cb);

    /* Habilita IRQ EXTI4_15 (pinos 4 a 15) com prioridade 2 */
    nvic_enable_irq(EXTI4_15_IRQn, 2);

    while(true){

    }
}

#endif


#ifdef __EXEMPLO_LED_SYSTICK__
/**
 * exemplo led por interrupção systick
 */
static void tick_cb(void) {
    /* seu código periódico aqui */
	gpio_toggle_pin(GPIOA, 5);
}

int main(void){
    /* Configura clock do core para 48 MHz via HSI */
    rcc_reset_to_hsi();
    if (!rcc_set_sysclk_from_hsi(48000000UL, RCC_AHB_DIV1, RCC_APB_DIV1)) {
        while (1) {} // erro
    }

    /* Lê clocks atuais */
    rcc_clocks_t clk;
    rcc_get_clocks(&clk);

    /* LED PA5 como saída push-pull, pull-none, alta velocidade */
    gpio_pin_init(GPIOA, 5, GPIO_MODE_OUTPUT, GPIO_OTYPE_PUSHPULL, GPIO_SPEED_HIGH, GPIO_PUPD_NONE);

    /* 1 ms, source=AHB, IRQ ON, prioridade 2 (0..3) */
    systick_init_ms(48000000UL, 1, true, true, 2);
    systick_set_callback(tick_cb);

    while(true){

    }
}

#endif

#ifdef __EXEMPLO_LED_POLLING__
/**
 * exemplo led por polling usando systick e delay
 */
int main(void){
    /* Configura clock do core para 48 MHz via HSI */
    rcc_reset_to_hsi();
    if (!rcc_set_sysclk_from_hsi(48000000UL, RCC_AHB_DIV1, RCC_APB_DIV1)) {
        while (1) {} // erro
    }

    /* Lê clocks atuais */
    rcc_clocks_t clk;
    rcc_get_clocks(&clk);

    /* LED PA5 como saída push-pull, pull-none, alta velocidade */
    gpio_pin_init(GPIOA, 5, GPIO_MODE_OUTPUT, GPIO_OTYPE_PUSHPULL, GPIO_SPEED_HIGH, GPIO_PUPD_NONE);

    /* 1 ms, source=AHB, IRQ ON, prioridade 2 (0..3) */
    systick_init_ms(48000000UL, 1, true, true, 2);

    while(true){
    	gpio_toggle_pin(GPIOA, 5);
    	systick_delay_ms(clk.hclk_hz, 1);
    }
}
#endif

#ifdef __EXEMPLO_USART_POLLING
int main(void)
{
    /* Core 48 MHz (opcional) */
    rcc_reset_to_hsi();
    rcc_set_sysclk_from_hsi(48000000UL, RCC_AHB_DIV1, RCC_APB_DIV1);

    /* Pinos USART1: PA9 (TX), PA10 (RX) em AF1 */
    gpio_pin_init(GPIOA, 9,  GPIO_MODE_ALT, GPIO_OTYPE_PUSHPULL, GPIO_SPEED_HIGH, GPIO_PUPD_UP);
    gpio_pin_set_altfunc(GPIOA, 9,  GPIO_AF1);
    gpio_pin_init(GPIOA, 10, GPIO_MODE_ALT, GPIO_OTYPE_PUSHPULL, GPIO_SPEED_HIGH, GPIO_PUPD_UP);
    gpio_pin_set_altfunc(GPIOA, 10, GPIO_AF1);

    /* Clock do APB da USART1 → use rcc_get_clocks se quiser calcular */
    rcc_clocks_t clk; rcc_get_clocks(&clk);
    uint32_t pclk = clk.pclk_hz; /* APB prescaler=1? então 48 MHz */

    usart_poll_t U1;
    usart_poll_config_t cfg = {
        .baud = 115200,
        .wordlen = USART_WORDLEN_8B,
        .parity = USART_PARITY_NONE,
        .stopbits = USART_STOPBITS_1,
        .oversample8 = 0 /* use OVER16 (mais simples e estável) */
    };
    usart_poll_init(&U1, USART1, pclk, &cfg);

    const char *hello = "USART1 polling ready @115200 8N1\r\n";
    usart_poll_write_str(&U1, hello, 200000);


    /* Loop forever */
	for(;;){
        uint16_t b;
        if (usart_poll_read_byte(&U1, &b, 0xFFFFFF)) {
            usart_poll_write_byte(&U1, b, 0xFFFFFF);
        }
	}
}
#endif

#ifdef __EXEMPLO_USART_IRQ
#define RX_RING_SZ 512   /* potência de 2 */
#define TX_RING_SZ 512

static usart_drv_t U1;
static uint8_t rx_ring[RX_RING_SZ];
static uint8_t tx_ring[TX_RING_SZ];

int main(void){
    /* Clock do core em 48 MHz (HSI/2 * 12) */
    rcc_reset_to_hsi();
    rcc_set_sysclk_from_hsi(48000000UL, RCC_AHB_DIV1, RCC_APB_DIV1);

    /* USART1 pinos: PA9 (TX), PA10 (RX) em AF1 */
    gpio_pin_init(GPIOA, 9,  GPIO_MODE_ALT, GPIO_OTYPE_PUSHPULL, GPIO_SPEED_HIGH, GPIO_PUPD_UP);
    gpio_pin_set_altfunc(GPIOA, 9, GPIO_AF1);
    gpio_pin_init(GPIOA, 10, GPIO_MODE_ALT, GPIO_OTYPE_PUSHPULL, GPIO_SPEED_HIGH, GPIO_PUPD_UP);
    gpio_pin_set_altfunc(GPIOA, 10, GPIO_AF1);

    /* Config USART: 115200-8N1, RX/TX por IRQ */
    usart_drv_config_t cfg = {
        .baud = 115200,
        .wordlen = UDRV_WORDLEN_8B,
        .parity  = UDRV_PARITY_NONE,
        .stopbits = UDRV_STOPBITS_1,
        .oversample8 = 0,
        .rx_engine = UDRV_ENGINE_IRQ,
        .tx_engine = UDRV_ENGINE_IRQ,
        .nvic_prio_usart = 2
    };

    /* pclk_hz = 48 MHz (APB2 = HCLK neste setup) */
    usart_init(&U1, USART1, 48000000UL, &cfg,
               rx_ring, RX_RING_SZ,     /* RX ring (pois RX=IRQ) */
               tx_ring, TX_RING_SZ);    /* TX ring */

    /* (callbacks são opcionais no modo IRQ; on_tx_done pode ser útil) */
    usart_set_callbacks(&U1, NULL, NULL, NULL);

    /* Mensagem inicial */
    const char *hello = "USART1 IRQ ready\r\n";
    usart_write(&U1, hello, (uint32_t)strlen(hello));

    /* Loop: eco do que chegar */
    for (;;)
    {
        uint8_t buf[64];
        uint32_t n = usart_read(&U1, buf, sizeof buf);
        if (n) {
            /* devolve o que recebeu */
            usart_write(&U1, buf, n);
        }
        __asm volatile ("nop");
    }
}
#endif

#ifdef __EXEMPLO_USART_DMA
#define RX_DMA_BUF_SZ 1024  /* buffer circular para RX por DMA */
#define TX_RING_SZ    1024  /* ring para TX (sempre) */

static usart_drv_t U1;
static uint8_t rx_dma_buf[RX_DMA_BUF_SZ];
static uint8_t tx_ring[TX_RING_SZ];

/* Callback: sempre que ocorrer IDLE, entregamos o “chunk” recém-chegado.
   Aqui, por simplicidade, fazemos eco (TX também via DMA). */
static void on_rx_chunk(const uint8_t *data, uint32_t len)
{
    /* eco direto do bloco recebido */
    usart_write(&U1, data, len);
}

static void on_tx_done(void)
{
    /* opcional: sinalizar fim de rajada DMA de TX */
    (void)0;
}

static void on_error(uint32_t usart_isr, uint32_t dma_flags)
{
    /* trate erros conforme necessidade (log, reset, etc.) */
    (void)usart_isr; (void)dma_flags;
}

int main(void)
{
    /* Clock 48 MHz */
    rcc_reset_to_hsi();
    rcc_set_sysclk_from_hsi(48000000UL, RCC_AHB_DIV1, RCC_APB_DIV1);

    /* Inicie o roteador de DMA UMA vez no boot (define as ISRs únicas de DMA) */
    dma_router_init(2); /* prioridade 2 (0..3 no Cortex-M0) */

    /* USART1 pinos: PA9 (TX), PA10 (RX) em AF1 */
    gpio_pin_init(GPIOA, 9,  GPIO_MODE_ALT, GPIO_OTYPE_PUSHPULL, GPIO_SPEED_HIGH, GPIO_PUPD_UP);
    gpio_pin_set_altfunc(GPIOA, 9, GPIO_AF1);
    gpio_pin_init(GPIOA, 10, GPIO_MODE_ALT, GPIO_OTYPE_PUSHPULL, GPIO_SPEED_HIGH, GPIO_PUPD_UP);
    gpio_pin_set_altfunc(GPIOA, 10, GPIO_AF1);

    /* Config: 115200-8N1, RX=DMA (circular + IDLE), TX=DMA (rajadas); prioridade de USART=2 */
    usart_drv_config_t cfg = {
        .baud = 115200,
        .wordlen = UDRV_WORDLEN_8B,
        .parity  = UDRV_PARITY_NONE,
        .stopbits = UDRV_STOPBITS_1,
        .oversample8 = 0,
        .rx_engine = UDRV_ENGINE_DMA,
        .tx_engine = UDRV_ENGINE_DMA,
        .nvic_prio_usart = 2
    };

    usart_init(&U1, USART1, 48000000UL, &cfg,
               rx_dma_buf, RX_DMA_BUF_SZ,  /* RX = DMA circular */
               tx_ring,    TX_RING_SZ);    /* TX ring (rajadas DMA) */

    usart_set_callbacks(&U1, on_rx_chunk, on_tx_done, on_error);

    const char *hello = "USART1 DMA RX(IDLE)/TX ready\r\n";
    usart_write(&U1, hello, (uint32_t)strlen(hello));

    /* Nada a fazer no loop — RX via DMA notifica por IDLE e o callback “on_rx_chunk”
       já faz eco. O TX usa DMA em rajadas disparadas por usart_write. */
    for (;;){ __asm volatile ("nop"); }
}

/* No vetor de interrupções do startup:
   void USART1_IRQHandler(void);  // já implementada no driver

   As interrupções de DMA (DMA1_Channel2_3 / 4_5) ficam TODAS em dma_router.c,
   não adiciona nada no vetor além do que o dma_router já define. */
#endif

#ifdef __EXEMPLO_SPI_POLLING
static inline void cs_low(void){  gpio_write_pin(GPIOC, 4, 0); }
static inline void cs_high(void){ gpio_write_pin(GPIOC, 4, 1); }

int main(void)
{
    /* Clock 48 MHz */
    rcc_reset_to_hsi();
    rcc_set_sysclk_from_hsi(48000000UL, RCC_AHB_DIV1, RCC_APB_DIV1);

    /* SPI1 pins: AF0 */
    gpio_pin_init(GPIOA,5, GPIO_MODE_ALT, GPIO_OTYPE_PUSHPULL, GPIO_SPEED_HIGH, GPIO_PUPD_NONE); gpio_pin_set_altfunc(GPIOA,5, GPIO_AF0);
    gpio_pin_init(GPIOA,6, GPIO_MODE_ALT, GPIO_OTYPE_PUSHPULL, GPIO_SPEED_HIGH, GPIO_PUPD_UP  ); gpio_pin_set_altfunc(GPIOA,6, GPIO_AF0);
    gpio_pin_init(GPIOA,7, GPIO_MODE_ALT, GPIO_OTYPE_PUSHPULL, GPIO_SPEED_HIGH, GPIO_PUPD_NONE); gpio_pin_set_altfunc(GPIOA,7, GPIO_AF0);

    /* CS em PC4 */
    gpio_pin_init(GPIOC,4, GPIO_MODE_OUTPUT, GPIO_OTYPE_PUSHPULL, GPIO_SPEED_HIGH, GPIO_PUPD_NONE);
    cs_high();

    /* Config SPI polling */
    spi_poll_t SPIx;
    spi_poll_config_t cfg = {
        .mode = SPI_MODE0,
        .baud_div = SPI_BR_DIV32,          /* 48 MHz / 8 = 6 MHz */
        .bit_order = SPI_MSB_FIRST,
        .datasize = SPI_DS_8BIT,
        .nss_mode = SPI_NSS_SOFT,         /* se você atualizou o header; senão use sw_nss=1 */
        .nssp_pulse = 0,
        .cs_assert = cs_low,
        .cs_release = cs_high
    };
    spi_poll_init(&SPIx, SPI1, &cfg);

    /* 0x9F + ler 3 bytes */
    uint8_t cmd = 0x9F, id[3] = {0};
    spi_cs_assert(&SPIx);
    spi_poll_write(&SPIx, &cmd, 1, 200000);
    spi_poll_read (&SPIx, id,  3, 200000);
    spi_cs_release(&SPIx);

    while (1) { __asm volatile ("nop"); }
}
#endif

#ifdef __EXEMPLO_SPI_IRQ
/* CS em PC4 (NSS_SOFT) */
static inline void cs_low(void){  gpio_write_pin(GPIOC, 4, 0); }
static inline void cs_high(void){ gpio_write_pin(GPIOC, 4, 1); }

static spi_drv_t SPIx;

static void on_done(void){ /* transação terminou */ }
static void on_err(uint32_t sr, uint32_t df){ (void)sr; (void)df; /* trate/log se quiser */ }

int main(void)
{
    rcc_reset_to_hsi();
    rcc_set_sysclk_from_hsi(48000000UL, RCC_AHB_DIV1, RCC_APB_DIV1);

    /* Pinos SPI1 (AF0) */
    gpio_pin_init(GPIOA,5, GPIO_MODE_ALT, GPIO_OTYPE_PUSHPULL, GPIO_SPEED_HIGH, GPIO_PUPD_NONE); gpio_pin_set_altfunc(GPIOA,5, GPIO_AF0);
    gpio_pin_init(GPIOA,6, GPIO_MODE_ALT, GPIO_OTYPE_PUSHPULL, GPIO_SPEED_HIGH, GPIO_PUPD_UP  ); gpio_pin_set_altfunc(GPIOA,6, GPIO_AF0);
    gpio_pin_init(GPIOA,7, GPIO_MODE_ALT, GPIO_OTYPE_PUSHPULL, GPIO_SPEED_HIGH, GPIO_PUPD_NONE); gpio_pin_set_altfunc(GPIOA,7, GPIO_AF0);

    /* CS software em PC4 */
    gpio_pin_init(GPIOC,4, GPIO_MODE_OUTPUT, GPIO_OTYPE_PUSHPULL, GPIO_SPEED_HIGH, GPIO_PUPD_NONE);
    cs_high();

    /* Config SPI (IRQ) */
    spi_drv_config_t cfg = {
        .mode=SPI_MODE0,
        .baud_div=SPI_BR_DIV8,
        .bit_order=SPI_MSB_FIRST,
        .datasize=SPI_DS_8BIT,
        .nss_mode=SPI_NSS_SOFT,     /* vamos manter CS baixo entre fases */
        .nssp_pulse=0,
        .tx_engine=SPI_ENGINE_IRQ,
        .rx_engine=SPI_ENGINE_IRQ,
        .nvic_prio_spi=2,
        .cs_assert=cs_low,
        .cs_release=cs_high
    };
    spi_init(&SPIx, SPI1, &cfg);
    spi_set_callbacks(&SPIx, on_done, on_err);

    /* Exemplo: write-then-read (0x9F + 3 bytes) mantendo CS baixo */
    uint8_t cmd = 0x9F, id[3];
    spi_write_then_read_async(&SPIx, &cmd, 1, id, 3);
    while (spi_is_busy(&SPIx)) { __asm volatile ("nop"); }

    while (1){ __asm volatile ("nop"); }
}

/* No vetor de interrupções:
   void SPI1_IRQHandler(void);  // já implementada no driver */
#endif

#ifdef __EXEMPLO_SPI_DMA
/* CS em PC4 (NSS_SOFT) */
static inline void cs_low(void){  gpio_write_pin(GPIOC, 4, 0); }
static inline void cs_high(void){ gpio_write_pin(GPIOC, 4, 1); }

static spi_drv_t SPIx;

static void on_done(void) { /* terminou as 2 fases */
}
static void on_err(uint32_t sr, uint32_t df) {
	(void) sr;
	(void) df; /* trate/log se quiser */
}

int main(void)
{
    rcc_reset_to_hsi();
    rcc_set_sysclk_from_hsi(48000000UL, RCC_AHB_DIV1, RCC_APB_DIV1);

    /* Inicie o roteador UMA vez no boot (centraliza ISRs de DMA) */
    dma_router_init(2);

    /* Pinos SPI1 (AF0) */
    gpio_pin_init(GPIOA,5, GPIO_MODE_ALT, GPIO_OTYPE_PUSHPULL, GPIO_SPEED_HIGH, GPIO_PUPD_NONE); gpio_pin_set_altfunc(GPIOA,5, GPIO_AF0);
    gpio_pin_init(GPIOA,6, GPIO_MODE_ALT, GPIO_OTYPE_PUSHPULL, GPIO_SPEED_HIGH, GPIO_PUPD_UP  ); gpio_pin_set_altfunc(GPIOA,6, GPIO_AF0);
    gpio_pin_init(GPIOA,7, GPIO_MODE_ALT, GPIO_OTYPE_PUSHPULL, GPIO_SPEED_HIGH, GPIO_PUPD_NONE); gpio_pin_set_altfunc(GPIOA,7, GPIO_AF0);

    /* CS software em PC4 */
    gpio_pin_init(GPIOC,4, GPIO_MODE_OUTPUT, GPIO_OTYPE_PUSHPULL, GPIO_SPEED_HIGH, GPIO_PUPD_NONE);
    cs_high();

    /* Config SPI (DMA nos dois sentidos) */
    spi_drv_config_t cfg = {
        .mode=SPI_MODE0,
        .baud_div=SPI_BR_DIV32,
        .bit_order=SPI_MSB_FIRST,
        .datasize=SPI_DS_8BIT,
        .nss_mode=SPI_NSS_SOFT,     /* manter CS baixo entre as fases */
        .nssp_pulse=0,
        .tx_engine=SPI_ENGINE_DMA,
        .rx_engine=SPI_ENGINE_DMA,
        .nvic_prio_spi=2,
        .cs_assert=cs_low,
        .cs_release=cs_high
    };
    spi_init(&SPIx, SPI1, &cfg);
    spi_set_callbacks(&SPIx, on_done, on_err);

    /* 0x9F + ler 3 bytes com CS contínuo (DMA faz as duas fases) */
    uint8_t cmd = 0x9F, id[3];
    spi_write_then_read_async(&SPIx, &cmd, 1, id, 3);
    while (spi_is_busy(&SPIx)) { __asm volatile ("nop"); }

    while (1){ __asm volatile ("nop"); }
}

/* No vetor:
   void SPI1_IRQHandler(void);           // driver SPI
   // As ISRs de DMA (DMA1_Channel2_3 / 4_5) ficam TODAS em dma_router.c */
#endif


#ifdef __EXEMPLO_TIMER_EVENTO
static void tick_cb(uint32_t sr, void *ctx){
	(void)sr;
	(void)ctx; /* toggle LED, etc. */
	gpio_toggle_pin(GPIOA, 5);
}

int main(void)
{
    rcc_reset_to_hsi();
    rcc_set_sysclk_from_hsi(48000000UL, RCC_AHB_DIV1, RCC_APB_DIV1);

    /* Lê clocks atuais */
    rcc_clocks_t clk;
    rcc_get_clocks(&clk);

    /* LED PA5 como saída push-pull, pull-none, alta velocidade */
    gpio_pin_init(GPIOA, 5, GPIO_MODE_OUTPUT, GPIO_OTYPE_PUSHPULL, GPIO_SPEED_HIGH, GPIO_PUPD_NONE);

    static tim_handle_t h;
    tim_init_t cfg = {
      .clk_hz=clk.hclk_hz, .freq_hz=1000u, .psc=0,.arr=0,
      .mode=TIM_COUNT_UP, .arpe=1, .one_pulse=0, .repetition=0,
      .mms=2,          /* TRGO = Update (opcional p/ ADC) */
      .nvic_prio=2
    };
    tim_init(&h, TIM3, &cfg);
    tim_on_update(&h, tick_cb, NULL);
    tim_start(TIM3);

    for(;;){

    }
}
#endif

#ifdef __EXEMPLO_PWM_DUTY_VARIAVEL
/* =======================================================================
   Configura GPIO PA6 em AF1 para TIM3_CH1 (saída de PWM)
   ======================================================================= */
static void gpio_setup_tim3_ch1_pa6(void)
{
    /* PA6: Alternate Function, push-pull, alta velocidade, sem pull */
    gpio_pin_init(GPIOA, 6,
                  GPIO_MODE_ALT,
                  GPIO_OTYPE_PUSHPULL,
                  GPIO_SPEED_HIGH,
                  GPIO_PUPD_NONE);

    /* AF1 para TIM3_CH1 no PA6 */
    gpio_pin_set_altfunc(GPIOA, 6, GPIO_AF1);
}

/* =======================================================================
   Configura PWM 20 kHz no TIM3 CH1 com duty = 50%
   - Usa preload (OC1PE) e ARPE para atualização sem glitch
   - Sem interrupção/DMA
   ======================================================================= */
static void pwm20k_setup(void)
{
    static tim_handle_t h;

    /* Base do timer: freq=20kHz com clock de entrada 48 MHz */
    tim_init_t cfg = {
        .clk_hz     = 48000000u,  /* entrada do TIM3 (APB1=48 MHz no seu setup) */
        .freq_hz    = 20000u,     /* queremos 20 kHz no contador (Update rate)   */
        .psc        = 0,          /* ignorado pois freq_hz != 0                   */
        .arr        = 0,          /* idem                                         */
        .mode       = TIM_COUNT_UP,
        .arpe       = 1,          /* habilita preload do ARR                      */
        .one_pulse  = 0,
        .repetition = 0,          /* não se aplica a TIM3                         */
        .mms        = 0,          /* TRGO = Reset (não precisamos de TRGO aqui)   */
        .nvic_prio  = 2           /* não usamos IRQ, mas deixamos valor padrão    */
    };

    tim_init(&h, TIM3, &cfg);

    /* PWM em CH1: modo PWM1 + preload do CCR1 (OC1PE) */
    tim_set_oc_mode(TIM3, 1, TIM_OCM_PWM1, 1);
    tim_pwm_polarity(TIM3, 1, 1); /* ativo em nível alto */

    /* Duty = 50% → CCR1 = (ARR+1)/2 */
    uint16_t arr = (uint16_t)TIM3->ARR;
    tim_pwm_set_compare(TIM3, 1, (arr + 1u) / 2u);

    /* Habilita saída do canal */
    tim_pwm_enable(TIM3, 1, 1);

    /* Inicia o contador */
    tim_start(TIM3);
}

/* =======================================================================
   Helper opcional: ajuste de duty em "por mil" (0..1000)
   - Útil para variar o duty em runtime sem recalcular tudo
   ======================================================================= */
static void pwm_set_duty_promille(uint16_t promille) /* 0..1000 */
{
    if (promille > 1000u) promille = 1000u;
    uint16_t arr = (uint16_t)TIM3->ARR;            /* período atual */
    uint32_t ccr = ((uint32_t)(arr + 1u) * promille) / 1000u;
    tim_pwm_set_compare(TIM3, 1, (uint16_t)ccr);
}

/* =======================================================================
   main()
   ======================================================================= */
int main(void)
{
    /* 1) Clock do sistema: 48 MHz (conforme seus drivers RCC) */
    rcc_reset_to_hsi();
    /* Exemplo que você já usa: HSI/2 (4 MHz) * 12 = 48 MHz, AHB=1, APB=1 */
    if (!rcc_set_sysclk_from_hsi(48000000UL, RCC_AHB_DIV1, RCC_APB_DIV1)) {
        while (1) { /* erro no clock → segure aqui */ }
    }

    /* 2) GPIO: PA6 em AF1 (TIM3_CH1) */
    gpio_setup_tim3_ch1_pa6();

    /* 3) PWM 20 kHz @ TIM3 CH1 com 50% */
    pwm20k_setup();

    /* 4) Loop — opcional: variar duty lentamente (exemplo) */
    for (;;)
    {
        /* comente o bloco abaixo se quiser duty fixo */
#if 1
        for (uint16_t d = 0; d <= 1000; d += 10) {
            pwm_set_duty_promille(d);
            for (volatile uint32_t i=0; i<30000; ++i) __asm volatile ("nop");
        }
        for (int d = 1000; d >= 0; d -= 10) {
            pwm_set_duty_promille((uint16_t)d);
            for (volatile uint32_t i=0; i<30000; ++i) __asm volatile ("nop");
        }
#else
        __asm volatile ("nop"); /* duty fixo; nada a fazer */
#endif
    }
}
#endif

#ifdef __EXEMPLO_PWM_DMA
/* ============================================================
   Seletor do canal DMA para TIM3_CH1 (ajuste se necessário)
   Em muitos F0: TIM3_CH1 → DMA1 Channel 3
   ============================================================ */
#define DMA_CH_FOR_TIM3_CH1   3   /* 1..5 no F070 */

/* ============================================================
   PWM base: TIM3 CH1 em PA6/AF1 @ 20 kHz, duty inicial 50%
   ============================================================ */
static void gpio_setup_tim3_ch1_pa6(void)
{
    /* PA6 -> AF1 (TIM3_CH1), push-pull, alta velocidade, sem pull */
    gpio_pin_init(GPIOA, 6,
                  GPIO_MODE_ALT,
                  GPIO_OTYPE_PUSHPULL,
                  GPIO_SPEED_HIGH,
                  GPIO_PUPD_NONE);
    gpio_pin_set_altfunc(GPIOA, 6, GPIO_AF1);
}

static void pwm_setup(uint32_t freq_hz)
{
    static tim_handle_t h;

    tim_init_t cfg = {
        .clk_hz     = 48000000u,   /* clock do TIM3 */
        .freq_hz    = freq_hz,      /* 20 kHz */
        .psc        = 0, .arr = 0, /* ignorados quando freq_hz != 0 */
        .mode       = TIM_COUNT_UP,
        .arpe       = 1,
        .one_pulse  = 0,
        .repetition = 0,
        .mms        = 0,
        .nvic_prio  = 2
    };
    tim_init(&h, TIM3, &cfg);

    /* PWM1 em CH1 + preload (OC1PE) */
    tim_set_oc_mode(TIM3, 1, TIM_OCM_PWM1, 1);
    tim_pwm_polarity(TIM3, 1, 1);

    /* Duty = 50% */
    uint16_t arr = (uint16_t)TIM3->ARR;
    tim_pwm_set_compare(TIM3, 1, (arr + 1u) / 2u);

    /* Habilita saída e inicia */
    tim_pwm_enable(TIM3, 1, 1);
    tim_start(TIM3);
}

/* ============================================================
   Waveform para DMA → CCR1
   - N = 256 amostras; rampa 0..ARR (0..100%)
   - Se quiser seno, troque o preenchimento em fill_wave()
   ============================================================ */
#define N 1024
static uint16_t wav[N];

static void fill_wave(void)
{
    /* Gera rampa 0..ARR (duty 0..100%) */
    uint16_t arr = (uint16_t)TIM3->ARR;
    for (uint32_t i = 0; i < N; i++) {
        /* (ARR+1) * i / N ⇒ 0..ARR */
        uint32_t v = ((uint32_t)(arr + 1u) * i) / N;
        wav[i] = (uint16_t)v;
    }
}

/* ============================================================
   Callback do DMA (router)
   - flags: combinações de DMA_TCIF(ch), DMA_HTIF(ch), DMA_TEIF(ch)
   ============================================================ */
static volatile uint32_t g_tc_count = 0;
static volatile uint32_t g_te_count = 0;

static void dma_tim3_ch1_tc_cb(uint32_t flags, void *ctx)
{
    (void)ctx;
    /* Testa TC/TE para o canal configurado (genérico) */
    if (flags & DMA_TCIF(DMA_CH_FOR_TIM3_CH1)) g_tc_count++;
    if (flags & DMA_TEIF(DMA_CH_FOR_TIM3_CH1)) g_te_count++;
    /* se quiser, trate HT aqui também */
}

/* ============================================================
   PWM + DMA (mem→periph 16-bit) com UDE (Update event)
   ============================================================ */
static void pwm_dma_setup(void)
{
    /* 1) PWM base ligado */
	pwm_setup(20000);

    /* 2) Preenche a tabela a ser repetida */
    fill_wave();

    /* 3) Pedido de DMA do timer:
          - UDE (a cada Update → novo CCR1 por período)
          - alternativa: CC1DE (tocar em um ponto do ciclo) */
    tim_dma_enable_update(TIM3, 1);
    // tim_dma_enable_cc(TIM3, 1, 1);  /* alternativa */

    /* 4) Inicializa roteador (liga clock do DMA e NVIC) e registra callback */
    dma_router_init(2);
    dma_router_attach(DMA_CH_FOR_TIM3_CH1, dma_tim3_ch1_tc_cb, NULL);

    /* 5) Dispara DMA: mem→perif, 16-bit, MINC=1, circular=1, prioridade alta
          CPAR = &TIM3->CCR1 ; CMAR = wav ; CNDTR = N */
    (void)dma_router_start_mem2periph_16(
        /* ch */       DMA_CH_FOR_TIM3_CH1,
        /* periph */   (volatile void*)&TIM3->CCR1,
        /* mem */      (const void*)wav,
        /* len */      N,
        /* circular */ true,
        /* priority */ 2,   /* HIGH */
        /* tc_irq */   true,
        /* te_irq */   true
    );
}

/* ============================================================
   main
   ============================================================ */
int main(void)
{
    /* 0) Sistema @ 48 MHz (seu driver RCC) */
    rcc_reset_to_hsi();
    if (!rcc_set_sysclk_from_hsi(48000000UL, RCC_AHB_DIV1, RCC_APB_DIV1)) {
        while (1) { /* erro de clock */ }
    }

    /* 1) GPIO PA6 → AF1 (TIM3_CH1) */
    gpio_setup_tim3_ch1_pa6();

    /* 2) PWM + DMA */
    pwm_dma_setup();

    /* 3) Loop: observe g_tc_count/g_te_count no debugger */
    for (;;){
    	__asm volatile ("nop");
    }
}
#endif

#ifdef __EXEMPLO_PWM_DMA_RC
/* ============================================================
   Seletor do canal DMA para TIM3_CH1 (ajuste se necessário)
   Em muitos F0: TIM3_CH1 → DMA1 Channel 3
   ============================================================ */
#define DMA_CH_FOR_TIM3_CH1   3   /* 1..5 no F070 */

/* ==== Sine 256 pontos (UQ0.16: 0..65535) ==== */
static const uint16_t sine_u16_256[256] = {
  32768, 33572, 34375, 35178, 35979, 36779, 37575, 38369, 39160, 39947, 40729, 41507, 42279, 43046, 43807, 44560,
  45307, 46046, 46777, 47500, 48214, 48919, 49613, 50298, 50972, 51635, 52287, 52927, 53555, 54170, 54773, 55362,
  55938, 56499, 57047, 57579, 58097, 58600, 59087, 59558, 60013, 60451, 60873, 61278, 61666, 62036, 62389, 62724,
  63041, 63339, 63620, 63881, 64124, 64348, 64553, 64739, 64905, 65053, 65180, 65289, 65377, 65446, 65496, 65525,
  65535, 65525, 65496, 65446, 65377, 65289, 65180, 65053, 64905, 64739, 64553, 64348, 64124, 63881, 63620, 63339,
  63041, 62724, 62389, 62036, 61666, 61278, 60873, 60451, 60013, 59558, 59087, 58600, 58097, 57579, 57047, 56499,
  55938, 55362, 54773, 54170, 53555, 52927, 52287, 51635, 50972, 50298, 49613, 48919, 48214, 47500, 46777, 46046,
  45307, 44560, 43807, 43046, 42279, 41507, 40729, 39947, 39160, 38369, 37575, 36779, 35979, 35178, 34375, 33572,
  32768, 31963, 31160, 30357, 29556, 28756, 27960, 27166, 26375, 25588, 24806, 24028, 23256, 22489, 21728, 20975,
  20228, 19489, 18758, 18035, 17321, 16616, 15922, 15237, 14563, 13900, 13248, 12608, 11980, 11365, 10762, 10173,
  9597, 9036, 8488, 7956, 7438, 6935, 6448, 5977, 5522, 5084, 4662, 4257, 3869, 3499, 3146, 2811,
  2494, 2196, 1915, 1654, 1411, 1187, 982, 796, 630, 482, 355, 246, 158, 89, 39, 10,
  0, 10, 39, 89, 158, 246, 355, 482, 630, 796, 982, 1187, 1411, 1654, 1915, 2196,
  2494, 2811, 3146, 3499, 3869, 4257, 4662, 5084, 5522, 5977, 6448, 6935, 7438, 7956, 8488, 9036,
  9597, 10173, 10762, 11365, 11980, 12608, 13248, 13900, 14563, 15237, 15922, 16616, 17321, 18035, 18758, 19489,
  20228, 20975, 21728, 22489, 23256, 24028, 24806, 25588, 26375, 27166, 27960, 28756, 29556, 30357, 31160, 31963
};

/* ============================================================
   PWM base: TIM3 CH1 em PA6/AF1 @ 20 kHz, duty inicial 50%
   ============================================================ */
static void gpio_setup_tim3_ch1_pa6(void)
{
    /* PA6 -> AF1 (TIM3_CH1), push-pull, alta velocidade, sem pull */
    gpio_pin_init(GPIOA, 6,
                  GPIO_MODE_ALT,
                  GPIO_OTYPE_PUSHPULL,
                  GPIO_SPEED_HIGH,
                  GPIO_PUPD_NONE);
    gpio_pin_set_altfunc(GPIOA, 6, GPIO_AF1);
}

static void pwm_setup(uint32_t freq_hz)
{
    static tim_handle_t h;

    tim_init_t cfg = {
        .clk_hz     = 48000000u,   /* clock do TIM3 */
        .freq_hz    = freq_hz,      /* 20 kHz */
        .psc        = 0, .arr = 0, /* ignorados quando freq_hz != 0 */
        .mode       = TIM_COUNT_UP,
        .arpe       = 1,
        .one_pulse  = 0,
        .repetition = 0,
        .mms        = 0,
        .nvic_prio  = 2
    };
    tim_init(&h, TIM3, &cfg);

    /* PWM1 em CH1 + preload (OC1PE) */
    tim_set_oc_mode(TIM3, 1, TIM_OCM_PWM1, 1);
    tim_pwm_polarity(TIM3, 1, 1);

    /* Duty = 50% */
    uint16_t arr = (uint16_t)TIM3->ARR;
    tim_pwm_set_compare(TIM3, 1, (arr + 1u) / 2u);

    /* Habilita saída e inicia */
    tim_pwm_enable(TIM3, 1, 1);
    tim_start(TIM3);
}

/* ============================================================
   Waveform para DMA → CCR1
   - N = 256 amostras; rampa 0..ARR (0..100%)
   - Se quiser seno, troque o preenchimento em fill_wave()
   ============================================================ */
#define N 256
static uint16_t wav[N];

/* === Preenche wav[] (0..ARR) com seno de 256 pontos ===
   Arranjo: wav[i] = round( arr * LUT[i] / 65535 ).
   Use o ARR atual do TIM3 para “full scale”. */
static void fill_wave_sine(void)
{
    uint16_t arr = (uint16_t)TIM3->ARR;
    for (uint32_t i = 0; i < N; i++) {
        /* arredondamento: +32767 antes da divisão */
        uint32_t tmp = ((uint32_t)arr * (uint32_t)sine_u16_256[i] + 32767u) / 65535u;
        wav[i] = (uint16_t)tmp;
    }
}

/* ============================================================
   Callback do DMA (router)
   - flags: combinações de DMA_TCIF(ch), DMA_HTIF(ch), DMA_TEIF(ch)
   ============================================================ */
static volatile uint32_t g_tc_count = 0;
static volatile uint32_t g_te_count = 0;

static void dma_tim3_ch1_tc_cb(uint32_t flags, void *ctx)
{
    (void)ctx;
    /* Testa TC/TE para o canal configurado (genérico) */
    if (flags & DMA_TCIF(DMA_CH_FOR_TIM3_CH1)) g_tc_count++;
    if (flags & DMA_TEIF(DMA_CH_FOR_TIM3_CH1)) g_te_count++;
    /* se quiser, trate HT aqui também */
}

/* ============================================================
   PWM + DMA (mem→periph 16-bit) com UDE (Update event)
   ============================================================ */
static void pwm_dma_setup(void)
{
    /* 1) PWM base ligado */
	pwm_setup(20000);

    /* 2) Preenche a tabela a ser repetida */
	fill_wave_sine();

    /* 3) Pedido de DMA do timer:
          - UDE (a cada Update → novo CCR1 por período)
          - alternativa: CC1DE (tocar em um ponto do ciclo) */
    tim_dma_enable_update(TIM3, 1);
    // tim_dma_enable_cc(TIM3, 1, 1);  /* alternativa */

    /* 4) Inicializa roteador (liga clock do DMA e NVIC) e registra callback */
    dma_router_init(2);
    dma_router_attach(DMA_CH_FOR_TIM3_CH1, dma_tim3_ch1_tc_cb, NULL);

    /* 5) Dispara DMA: mem→perif, 16-bit, MINC=1, circular=1, prioridade alta
          CPAR = &TIM3->CCR1 ; CMAR = wav ; CNDTR = N */
    (void)dma_router_start_mem2periph_16(
        /* ch */       DMA_CH_FOR_TIM3_CH1,
        /* periph */   (volatile void*)&TIM3->CCR1,
        /* mem */      (const void*)wav,
        /* len */      N,
        /* circular */ true,
        /* priority */ 2,   /* HIGH */
        /* tc_irq */   true,
        /* te_irq */   true
    );
}

/* ============================================================
   main
   ============================================================ */
int main(void)
{
    /* 0) Sistema @ 48 MHz (seu driver RCC) */
    rcc_reset_to_hsi();
    if (!rcc_set_sysclk_from_hsi(48000000UL, RCC_AHB_DIV1, RCC_APB_DIV1)) {
        while (1) { /* erro de clock */ }
    }

    /* 1) GPIO PA6 → AF1 (TIM3_CH1) */
    gpio_setup_tim3_ch1_pa6();

    /* 2) PWM + DMA */
    pwm_dma_setup();

    /* 3) Loop: observe g_tc_count/g_te_count no debugger */
    for (;;){
    	__asm volatile ("nop");
    }
}
#endif

#ifdef __EXEMPLO_TIM_OUTPUT_COMPARE
/*
Timer em 1 MHz (PSC=47, ARR=0xFFFF).

Canal em OC TOGGLE: o próprio hardware alterna o nível do pino a cada “match”.

A cada interrupção de CC1, somamos delta_ticks ao CCR1 para agendar o próximo toggle.

Ex.: delta_ticks=500 → 500 µs entre toggles → 1 kHz de quadrada no pino.*/

/* ====== Configuração do pino ======
   PA6 → AF1 (TIM3_CH1) como saída alternada */
static void gpio_setup_tim3_ch1_pa6(void)
{
    gpio_pin_init(GPIOA, 6,
                  GPIO_MODE_ALT,
                  GPIO_OTYPE_PUSHPULL,
                  GPIO_SPEED_HIGH,
                  GPIO_PUPD_NONE);
    gpio_pin_set_altfunc(GPIOA, 6, GPIO_AF1);
}

/* ====== Parâmetros do OC ====== */
static volatile uint16_t g_delta_ticks = 500; /* 500 us entre toggles ⇒ 1 kHz @ CNT=1MHz */
static tim_handle_t g_tim3;

/* Callback de CC1: reagenda próximo toggle (CCR1 += delta) */
static void tim3_cc1_cb(uint32_t sr, void *ctx)
{
    (void)sr; (void)ctx;
    /* lê CCR1 atual e soma delta (wrap natural em 16 bits) */
    uint16_t ccr = tim_read_ccr(TIM3, 1);
    tim_set_compare(TIM3, 1, (uint16_t)(ccr + g_delta_ticks));
}

/* Setup do OC (toggle) no TIM3 CH1 */
static void tim3_oc_toggle_setup(void)
{
    /* Base: contador a 1 MHz (48 MHz / 48) */
    tim_init_t cfg = {
        .clk_hz=48000000u, .freq_hz=0,     /* vamos configurar PSC/ARR manualmente */
        .psc=48-1, .arr=0xFFFF,
        .mode=TIM_COUNT_UP, .arpe=0, .one_pulse=0, .repetition=0,
        .mms=0, .nvic_prio=2
    };
    tim_init(&g_tim3, TIM3, &cfg);

    /* Canal 1 como saída “Output Compare”, modo TOGGLE (OCM=011), sem preload */
    tim_set_oc_mode(TIM3, 1, TIM_OCM_TOGGLE, 0);

    /* Habilita a saída do canal (CC1E) */
    tim_oc_output_enable(TIM3, 1, 1);

    /* Programa o 1º evento: daqui a delta_ticks a partir do CNT atual */
    uint16_t now = (uint16_t)TIM3->CNT;
    tim_set_compare(TIM3, 1, (uint16_t)(now + g_delta_ticks));

    /* Habilita a interrupção de CC1 e registra callback */
    tim_on_cc(&g_tim3, 1, tim3_cc1_cb, NULL);

    /* Inicia contador */
    tim_start(TIM3);
}

/* ===== main: OC demo ===== */
int main(void)
{
    rcc_reset_to_hsi();
    if (!rcc_set_sysclk_from_hsi(48000000UL, RCC_AHB_DIV1, RCC_APB_DIV1)) {
        while (1) {}
    }

    gpio_setup_tim3_ch1_pa6();
    tim3_oc_toggle_setup();

    for(;;){
    	__asm volatile ("nop");
        /* Se quiser mudar a frequência em runtime:
           g_delta_ticks = 1000; // 500 Hz, etc. */
    }
}
#endif

#ifdef __EXEMPLO_TIM_INPUT_CAPTURE
/* PA7 -> AF4 (TIM14_CH1) */
static void gpio_setup_pa7_tim14_ch1(void)
{
    gpio_pin_init(GPIOA, 7,
                  GPIO_MODE_ALT,
                  GPIO_OTYPE_PUSHPULL,
                  GPIO_SPEED_HIGH,
                  GPIO_PUPD_DOWN);
    gpio_pin_set_altfunc(GPIOA, 7, /*AF4*/ 4);
}

static tim_handle_t g_tim14_ic;
static volatile uint16_t g_last_cc = 0;
static volatile uint16_t g_period_ticks = 0;
static volatile uint32_t g_freq_hz_est = 0;
static uint32_t g_tick_hz = 0;
static uint8_t g_times = 0;

static void tim14_cc1_cb(uint32_t sr, void *ctx)
{
    (void)sr;(void)ctx;
    uint16_t now = (uint16_t)TIM14->CCR1;
    uint16_t dt  = (uint16_t)(now - g_last_cc);
    g_last_cc = now;
    g_period_ticks = dt;
    g_freq_hz_est  = dt ? (g_tick_hz / (uint32_t)dt) : 0;

    if( g_times == 0 ){
    	g_times = 1;
    }
    else{
    	g_times = 0;//aqui se olharmos o valor de g_freq_hz_est, você irá encontrar o valor da frequencia lida
    }
}

static void tim14_ic_setup_from_pa7(uint32_t tim_clk_hz)
{
    tim_init_t cfg = {
        .clk_hz=tim_clk_hz, .freq_hz=0,
        .psc=48-1, .arr=0xFFFF,
        .mode=TIM_COUNT_UP, .arpe=0, .one_pulse=0, .repetition=0,
        .mms=0, .nvic_prio=2
    };
    tim_init(&g_tim14_ic, TIM14, &cfg);

    g_tick_hz = tim_clk_hz / (cfg.psc + 1u);

    /* TIM14 tem CCMR1 com CH1 em IC: CC1S=01, IC1F=0x3 */
    tim_ic_config(TIM14, 1, TIM_EDGE_RISING, 0x1);

    g_last_cc = (uint16_t)TIM14->CCR1;
    tim_on_cc(&g_tim14_ic, 1, tim14_cc1_cb, NULL);
    tim_start(TIM14);
}

/* main alternativo: gerador em PA7 */
int main(void)
{
    rcc_reset_to_hsi();
    if (!rcc_set_sysclk_from_hsi(48000000UL, RCC_AHB_DIV1, RCC_APB_DIV1)) while(1){}

    gpio_setup_pa7_tim14_ch1();
    tim14_ic_setup_from_pa7(48000000u);

    for(;;){ __asm volatile ("nop"); }
}
#endif

#ifdef __EXEMPLO_I2C_POLLING_DISPLAY_SSD1306
/* PB8=SCL, PB9=SDA → AF1, open-drain, alta velocidade */
static void i2c1_gpio_pb8_pb9_setup(void)
{
    gpio_pin_init(GPIOB, 8, GPIO_MODE_ALT, GPIO_OTYPE_OPENDRAIN, GPIO_SPEED_HIGH, GPIO_PUPD_NONE);
    gpio_pin_init(GPIOB, 9, GPIO_MODE_ALT, GPIO_OTYPE_OPENDRAIN, GPIO_SPEED_HIGH, GPIO_PUPD_NONE);
    gpio_pin_set_altfunc(GPIOB, 8, 1); /* AF1 I2C1_SCL */
    gpio_pin_set_altfunc(GPIOB, 9, 1); /* AF1 I2C1_SDA */
}

/* Envia 1 comando ao SSD1306 (control=0x00), retorna true se ACK (driver OK) */
static bool ssd1306_send_cmd(I2C_TypeDef *i2c, uint8_t addr7, uint8_t cmd)
{
    uint8_t frame[2] = { 0x00, cmd }; /* 0x00 = controle “comando” */
    return i2c_poll_write(i2c, addr7, frame, 2, 100000);
}

/* Tenta 0x3C e 0x3D; retorna o que respondeu ou 0xFF se nenhum */
static uint8_t ssd1306_probe(I2C_TypeDef *i2c)
{
    if (ssd1306_send_cmd(i2c, 0x3C, 0xE3)) return 0x3C; /* NOP */
    if (ssd1306_send_cmd(i2c, 0x3D, 0xE3)) return 0x3D; /* NOP */
    return 0xFF;
}

int main(void)
{
    /* 1) 48 MHz no core/APB */
    rcc_reset_to_hsi();
    if (!rcc_set_sysclk_from_hsi(48000000UL, RCC_AHB_DIV1, RCC_APB_DIV1)) while (1) {}

    /* 2) PB8/PB9 em AF1 open-drain */
    i2c1_gpio_pb8_pb9_setup();

    /* 3) I2C1 init (100 kHz com PCLK=48 MHz; ajuste se precisar) */
    i2c_poll_cfg_t icfg = {
        .inst = I2C1,
        .timingr = I2C_TIMINGR_100K_48M,  /* 0x00303D5B (padrão) */
        .analog_filter_en = 1,
        .digital_filter   = 0,
        .own7bit          = 0
    };
    i2c_poll_init(&icfg);

    /* 4) Probe SSD1306 com NOP (sem mexer na tela) */
    uint8_t addr = ssd1306_probe(I2C1);  /* breakpoint aqui */
    /* addr == 0x3C ou 0x3D → OK (driver+bus ok, device respondeu)
       addr == 0xFF       → NACK (checar AF1, pull-ups, TIMINGR ou endereço) */

    /* 5) (opcional) mais dois comandos que não “desenham”: */
    if (addr != 0xFF) {
        (void)ssd1306_send_cmd(I2C1, addr, 0xAE); /* DISPLAY OFF */
        (void)ssd1306_send_cmd(I2C1, addr, 0xAF); /* DISPLAY ON  (só liga/desliga) */
        (void)ssd1306_send_cmd(I2C1, addr, 0xE3); /* NOP de novo */
    }

    for (;;) { __asm volatile ("nop"); }
}
#endif

#ifdef __EXEMPLO_I2C_IRQ_SSD1306
int main(void)
{
    rcc_reset_to_hsi();
    rcc_set_sysclk_from_hsi(48000000UL, RCC_AHB_DIV1, RCC_APB_DIV1);

    /* setup pinos PB8/PB9 → AF1 */
    gpio_pin_init(GPIOB, 8, GPIO_MODE_ALT, GPIO_OTYPE_OPENDRAIN, GPIO_SPEED_HIGH, GPIO_PUPD_NONE);
    gpio_pin_init(GPIOB, 9, GPIO_MODE_ALT, GPIO_OTYPE_OPENDRAIN, GPIO_SPEED_HIGH, GPIO_PUPD_NONE);
    gpio_pin_set_altfunc(GPIOB, 8, 1);
    gpio_pin_set_altfunc(GPIOB, 9, 1);

    i2c_drv_t i2c1d;
    i2c_irqdma_init(&i2c1d, I2C1, I2C_TIMINGR_100K_48M, 1, 0, 0, 2);

    uint8_t frame[2] = { 0x00, 0xE3 }; /* controle=cmd, NOP */
    i2c1d.done = 0;
    i2c_irqdma_start(&i2c1d, 0x3C, frame, sizeof(frame), NULL, 0, /*dma_tx*/0, /*dma_rx*/0);
    bool ok = i2c_irqdma_wait_done(&i2c1d, 200000);
    (void)ok;
    /* addr == 0x3C/0x3D => OK. 0xFF => falhou (endereço/timing/bus). */
    for(;;){ __asm volatile ("nop"); }
}
#endif

#ifdef __EXEMPLO_I2C_DMA_SSD1306
int main(void)
{
    rcc_reset_to_hsi();
    rcc_set_sysclk_from_hsi(48000000UL, RCC_AHB_DIV1, RCC_APB_DIV1);

    /* setup pinos PB8/PB9 → AF1 */
    gpio_pin_init(GPIOB, 8, GPIO_MODE_ALT, GPIO_OTYPE_OPENDRAIN, GPIO_SPEED_HIGH, GPIO_PUPD_NONE);
    gpio_pin_init(GPIOB, 9, GPIO_MODE_ALT, GPIO_OTYPE_OPENDRAIN, GPIO_SPEED_HIGH, GPIO_PUPD_NONE);
    gpio_pin_set_altfunc(GPIOB, 8, 1);
    gpio_pin_set_altfunc(GPIOB, 9, 1);

    i2c_drv_t i2c1d;
    i2c_irqdma_init(&i2c1d, I2C1, I2C_TIMINGR_100K_48M, 1, 0, 0, 2);

    /* mapeamento correto p/ F070 */
    i2c_irqdma_set_dma_channels(&i2c1d, 2, 3);

    /* quadro: 0x00 (controle comando) + 0xE3 (NOP) */
    uint8_t frame[2] = { 0x00, 0xE3 };

    /* start com DMA no TX */
    i2c1d.done = 0;
    bool ok = i2c_irqdma_start(&i2c1d, 0x3C, frame, sizeof(frame), NULL, 0,
                                    /*dma_tx=*/1, /*dma_rx=*/0);
    (void)ok;

    for(;;){ __asm volatile ("nop"); }
}
#endif

#ifdef __EXEMPLO_ADC_POLL_2_CANAIS
int main(void){
    gpio_pin_init(GPIOA, 0, GPIO_MODE_ANALOG, GPIO_OTYPE_PUSHPULL, GPIO_SPEED_HIGH, GPIO_PUPD_NONE);
    gpio_pin_init(GPIOA, 1, GPIO_MODE_ANALOG, GPIO_OTYPE_PUSHPULL, GPIO_SPEED_HIGH, GPIO_PUPD_NONE);

  adc_bm_config_t cfg = adc_bm_default();
  adc_bm_init(&cfg);

  uint8_t chans[] = {0,1};
  adc_bm_set_channels_list(chans, 2);

  uint16_t v[2];
  while (1){
    uint8_t n = adc_bm_read_sequence_polling(v, 2); /* v[0]=IN0, v[1]=IN1 (ASC) */
    (void)n;
    __asm volatile ("nop"); /* breakpoint pra ver v[] */
  }
}
#endif

#ifdef __EXEMPLO_ADC_IRQ_1_CANAL
static volatile uint16_t g_last = 0;
static void cb(uint16_t s, uint8_t idx, bool eos, void *ctx){
  (void)idx; (void)ctx;
  if (!eos) g_last = s;
}

int main(void){
    gpio_pin_init(GPIOA, 0, GPIO_MODE_ANALOG, GPIO_OTYPE_PUSHPULL, GPIO_SPEED_HIGH, GPIO_PUPD_NONE);

  adc_bm_config_t cfg = adc_bm_default();
  adc_bm_init(&cfg);

  adc_bm_set_channels_mask(ADC_CHSELR_CH(0));

  adc_bm_it_start(/*prio*/1, /*EOC*/true, /*EOS*/true, /*OVR*/true, cb, NULL);

  while (1){ __asm volatile ("nop"); } /* ver g_last no debug */
}
#endif

#ifdef __EXEMPLO_ADC_DMA_2_CANAIS
static volatile uint16_t g_buf[2];
static volatile uint8_t  g_tc = 0, g_err = 0;

static void dma_cb(uint32_t flags, void *ctx) {
	(void) ctx;
	if (flags & DMA_TEIF1)
		g_err = 1;
	if (flags & DMA_TCIF1)
		g_tc = 1; /* g_buf[0]=IN0, g_buf[1]=IN1 */
}

int main(void) {
    gpio_pin_init(GPIOA, 0, GPIO_MODE_ANALOG, GPIO_OTYPE_PUSHPULL, GPIO_SPEED_HIGH, GPIO_PUPD_NONE);
    gpio_pin_init(GPIOA, 1, GPIO_MODE_ANALOG, GPIO_OTYPE_PUSHPULL, GPIO_SPEED_HIGH, GPIO_PUPD_NONE);

	adc_bm_config_t cfg = adc_bm_default();
	cfg.dma_enable = true; /* não circular */
	adc_bm_init(&cfg);

	uint8_t chans[] = { 0, 1 };
	adc_bm_set_channels_list(chans, 2);

	(void) adc_bm_dma_start_oneshot((uint16_t*) g_buf, 2, /*prio*/3, /*TE*/true,
			dma_cb, NULL);

	while (1) {
		if (g_tc) {
			g_tc = 0;
			__asm volatile ("nop");
			/* ver g_buf[] */}
		if (g_err) {
			g_err = 0;
			__asm volatile ("nop");
		}
	}
}
#endif

#ifdef __EXEMPLO_WATCHDOG_NORMAL
int main(void)
{
    /* Escolha PR/RLR automaticamente para ~1000 ms com LSI ~40 kHz */
    uint8_t  pr; uint16_t rlr;
    iwdg_bm_pick(/*lsi_hz*/40000, /*ms*/1000, &pr, &rlr);

    iwdg_bm_cfg_t cfg = {
        .lsi_hz = 40000,
        .pr  = pr,
        .rlr = rlr,
        .win = 0x0FFF /* janela “ampla” → sem janela de refresh estrita */
    };
    iwdg_bm_init_start(&cfg);

    while (1) {
        /* ... sua aplicação ... */
        iwdg_bm_kick();      /* dê o “pet” antes de 1 s */
        /* opcionalmente: __WFI(); */
    }
}
#endif

#ifdef __EXEMPLO_WATCH_IRQ
static void early_wakeup(void *ctx)
{
    (void)ctx;
    /* Janela “quase fechando” (T==0x40). Chute agora para evitar reset. */
    wwdg_bm_kick(0x7F);
}

int main(void)
{
	rcc_reset_to_hsi();
	rcc_preset_sysclk_48mhz_hsi();

    /* Configura: prescaler /8, janela W=0x50 (exemplo), EWI ligado */
    wwdg_bm_cfg_t cfg = {
        .wdgtb = 3,             /* /8 */
        .window = 0x50,         /* refresh permitido quando T < 0x50 */
        .ewi_enable = true,
        .nvic_prio  = 1,
        .cb = early_wakeup,
        .cb_ctx = NULL
    };

    /* Start com T inicial = 0x7F.
       Daqui em diante, o contador desce… quando atingir 0x40, entra no EWI. */
    wwdg_bm_init(&cfg, 0x7F);

    while (1) {
        /* Se preferir *não* depender do EWI, você pode fazer:
           if (wwdg_bm_counter_now() < 0x50) { wwdg_bm_kick(0x7F); }
           Isso garante refresh dentro da janela manualmente. */
    	__asm volatile ("nop");
    }
}
#endif

int main(void){

}



